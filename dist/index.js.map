{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import { ActionDef, StateHolder } from \"./state-holder\";\r\n\r\nexport { StateHolder }\r\n\r\nexport const stateHolderConfig = {\r\n    logger: true\r\n}\r\n\r\nexport type Action<T, I = any> = ((state: T) => T) | ((state: T, args: I) => T);\r\n/**\r\n * syntactic sugar to create a new action\r\n * @param label Name your action, only used in logging mode to have a more explicite name\r\n * @param action the action to dispatch\r\n * @returns a new action to use in the dispatch function of the state instance\r\n */\r\nexport const createAction = <T, I>(label: string, action: Action<T, I>): ActionDef<T, I> => ({ label, action })\r\n\r\nexport type Selector<T, O, I = any> = ((state: T) => O) | ((state: T, args: I) => O);\r\n/**\r\n * syntactic sugar to create a new selector\r\n * @param selector the select function\r\n * @returns a new selector to use with the select$ function of the state instance\r\n */\r\nexport const createSelector = <T, O, I = any>(selector: Selector<T, O, I>): Selector<T, O, I> => (selector)\r\n\r\n/**\r\n * syntactic sugar to create a new basic state holder. Usefull if you do not need to add any other behaviour to it, only dispatching and selecting outside the class is usefull to you.\r\n * @param initValues init value of the state\r\n * @returns a new basic state holder\r\n */\r\nexport const createBasicState = <T>(initValues: T): SimpleStateHolder<T> => {\r\n    return new SimpleStateHolder(initValues);\r\n}\r\n\r\nexport class SimpleStateHolder<T> extends StateHolder<T> {\r\n    constructor(initValues: T) { super(initValues); }\r\n}\r\n"],"names":["StateHolder"],"mappings":";;;;;;MAIa,oBAAoB;AAAA,EAC7B,QAAQ;AAAA;MAUC,eAAe,CAAO,OAAe,aAA6C,OAAO;MAQzF,iBAAiB,CAAgB,aAAoD;MAOrF,mBAAmB,CAAI,eAAwC;AACxE,SAAO,IAAI,kBAAkB;AAAA;gCAGSA,2BAAe;AAAA,EACrD,YAAY,YAAe;AAAE,UAAM;AAAA;AAAA;;;;;;;;;;;;;;"}