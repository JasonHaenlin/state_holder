{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import { BehaviorSubject, Observable, UnaryFunction, pipe } from \"rxjs\";\r\nimport { scan, shareReplay, map, distinctUntilChanged, filter } from \"rxjs/operators\";\r\n\r\n/**\r\n * Add a state holder manager to a class\r\n * Can be a simple state holder using the function `createBasicState` to create an instance of the stateHolder. You can also extend a class to add a state manager behaviour to it  (like service in Angular <(^^)> )\r\n * @param T interface represeting the state structure\r\n */\r\nexport abstract class StateHolder<T> {\r\n\r\n    private _stateHolderSource: BehaviorSubject<any>;\r\n    private _stateHolder$: Observable<T>;\r\n    private _lastActionName?: string;\r\n    private _initValue: T;\r\n    private _selectorsMap: { [key: string]: Observable<any> }\r\n\r\n    /**\r\n     * Keep the state of the defined model as `T`\r\n     * DevMode is enable in none production and log the model everytime it has been modified\r\n     * @param T initValue the init value of the model\r\n     *\r\n     * ```ts\r\n     * // structure of the state\r\n     * interface SampleState {\r\n     *     text: string;\r\n     * }\r\n     * // init state (when instantiating the class)\r\n     * const initSampleState: SampleState = {\r\n     *     text: '',\r\n     * }\r\n     * // create an action\r\n     * const setTextAction = createAction(\r\n     *         'Set text',\r\n     *         (state: SampleState, { text }: { text: string }): SampleState => ({ ...state, text })\r\n     * );\r\n     * // create a selector\r\n     * const textSelector = createSelector((state: SampleState): string => state.text);\r\n     * // instiate a new basic state holder\r\n     * const state = createBasicState(initSampleState);\r\n     * // dispatch and select example\r\n     * state.dispatch(setTextAction, { text: 'sample' });\r\n     * state.select$(textSelector).subscribe({next: (v) => console.log(v)});\r\n     * ```\r\n     */\r\n    constructor(initValues: T) {\r\n        this._stateHolderSource = new BehaviorSubject<T>(initValues);\r\n        this._initValue = initValues;\r\n        this._selectorsMap = {};\r\n        this._stateHolder$ = this._stateHolderSource\r\n            .pipe(\r\n                scan<[ActionDef<T, any>, any], T>(\r\n                    (all: T, act: [ActionDef<T, any>, any]) => {\r\n                        return act[0] ? act[0].action(all, act[1]) : all\r\n                    }, initValues),\r\n                shareReplay(1)\r\n            );\r\n        if (stateHolderConfig.logger) { this.devMode(); }\r\n    }\r\n\r\n    /**\r\n     * Warning : erase all the data and put it back in the original state.\r\n     * Next state value will match the iniValue defined in the constructor.\r\n     */\r\n    public get wipe(): T { return this._initValue; }\r\n\r\n    /**\r\n     * Retrieve the state Observable of the model\r\n     */\r\n    public get stateHolder$(): Observable<T> { return this._stateHolder$; }\r\n\r\n    /**\r\n     * Utility function to clear the corresponding keys values\r\n     * @param state the current state\r\n     * @param keys the keys to be reset to the default value\r\n     * @returns the new state\r\n     */\r\n    public clear(state: T, ...keys: (keyof T)[]): T {\r\n        const keysCleared = {} as T;\r\n        keys.forEach(k => this._initValue[k] != null ? keysCleared[k] = this._initValue[k] : null);\r\n        return { ...state, ...keysCleared };\r\n    }\r\n\r\n    /**\r\n     * Dispatch a new action to update the state\r\n     * @param actionDef `ActionDef<T, S>` dispatch an action created by `createAction()`\r\n     * @param args the arguments to dispatch to the state to update it\r\n     */\r\n    public dispatch<U, S>(actionDef: ActionDef<T, S>, args?: U): void {\r\n        this._lastActionName = actionDef.label;\r\n        this._stateHolderSource.next([actionDef, args]);\r\n    }\r\n\r\n    /**\r\n     * Select a value from the state\r\n     * The select cache the observable created by the createSelector using the name of it.\r\n     *\r\n     * If you change the behaviour of an already selected function with the same name,\r\n     * you will not get a new observable. You must create a new one with a new name.\r\n     *\r\n     * @param selector `Selector<T, O, I>` define the selector function\r\n     * @returns the observable corresponding to your selector function\r\n     */\r\n    public select$<I, O>(selector: Selector<T, O, I>, args?: I): Observable<O> {\r\n        const cachedObs = this._selectorsMap[selector.name];\r\n        if (cachedObs) {\r\n            return cachedObs as Observable<O>;\r\n        }\r\n        if (args) {\r\n            const newObs = this._stateHolder$.pipe(map((state: T) => selector(state, args)), this.processPipe());\r\n            this._selectorsMap[selector.name] = newObs;\r\n            return newObs;\r\n        }\r\n        const selectorWithoutArgs = selector as ((state: T) => O);\r\n        const newObs = this._stateHolder$.pipe(map((state: T) => selectorWithoutArgs(state)), this.processPipe());\r\n        this._selectorsMap[selector.name] = newObs;\r\n        return newObs;\r\n    }\r\n\r\n    private devMode(): void {\r\n        this._stateHolder$\r\n            .pipe(distinctUntilChanged())\r\n            .subscribe({ next: (state: T) => console.log({ action: this._lastActionName ?? 'initial', state: state }) });\r\n    }\r\n\r\n    private processPipe(): UnaryFunction<Observable<{}>, Observable<any>> {\r\n        return pipe(\r\n            filter((d: any) => d !== null && d !== undefined),\r\n            distinctUntilChanged(),\r\n        );\r\n    }\r\n\r\n}\r\n\r\nexport const stateHolderConfig = {\r\n    logger: true\r\n}\r\n\r\nexport interface ActionDef<T, I> {\r\n    label: string;\r\n    action: Action<T, I>;\r\n}\r\n\r\nexport type Action<T, I = any> = ((state: T) => T) | ((state: T, args: I) => T);\r\n/**\r\n * syntactic sugar to create a new action\r\n * @param label Name your action, only used in logging mode to have a more explicite name\r\n * @param action the action to dispatch\r\n * @returns a new action to use in the dispatch function of the state instance\r\n */\r\nexport const createAction = <T, I>(label: string, action: Action<T, I>): ActionDef<T, I> => ({ label, action })\r\n\r\nexport type Selector<T, O, I = any> = ((state: T) => O) | ((state: T, args: I) => O);\r\n/**\r\n * syntactic sugar to create a new selector\r\n * @param selector the select function\r\n * @returns a new selector to use with the select$ function of the state instance\r\n */\r\nexport const createSelector = <T, O, I = any>(selector: Selector<T, O, I>): Selector<T, O, I> => (selector)\r\n\r\n/**\r\n * syntactic sugar to create a new basic state holder. Usefull if you do not need to add any other behaviour to it, only dispatching and selecting outside the class is usefull to you.\r\n * @param initValues init value of the state\r\n * @returns a new basic state holder\r\n */\r\nexport const createBasicState = <T>(initValues: T): SimpleStateHolder<T> => {\r\n    return new SimpleStateHolder(initValues);\r\n}\r\n\r\nexport class SimpleStateHolder<T> extends StateHolder<T> {\r\n    constructor(initValues: T) { super(initValues); }\r\n}\r\n"],"names":["BehaviorSubject","scan","shareReplay","map","distinctUntilChanged","pipe","filter"],"mappings":";;;;;;;kBAQqC;AAAA,EAoCjC,YAAY,YAAe;AACvB,SAAK,qBAAqB,IAAIA,qBAAmB;AACjD,SAAK,aAAa;AAClB,SAAK,gBAAgB;AACrB,SAAK,gBAAgB,KAAK,mBACrB,KACGC,eACI,CAAC,KAAQ,QAAkC;AACvC,aAAO,IAAI,KAAK,IAAI,GAAG,OAAO,KAAK,IAAI,MAAM;AAAA,OAC9C,aACPC,sBAAY;AAEpB,QAAI,kBAAkB,QAAQ;AAAE,WAAK;AAAA;AAAA;AAAA,MAO9B,OAAU;AAAE,WAAO,KAAK;AAAA;AAAA,MAKxB,eAA8B;AAAE,WAAO,KAAK;AAAA;AAAA,EAQhD,MAAM,UAAa,MAAsB;AAC5C,UAAM,cAAc;AACpB,SAAK,QAAQ,OAAK,KAAK,WAAW,MAAM,OAAO,YAAY,KAAK,KAAK,WAAW,KAAK;AACrF,WAAO,IAAK,UAAU;AAAA;AAAA,EAQnB,SAAe,WAA4B,MAAgB;AAC9D,SAAK,kBAAkB,UAAU;AACjC,SAAK,mBAAmB,KAAK,CAAC,WAAW;AAAA;AAAA,EAatC,QAAc,UAA6B,MAAyB;AACvE,UAAM,YAAY,KAAK,cAAc,SAAS;AAC9C,QAAI,WAAW;AACX,aAAO;AAAA;AAEX,QAAI,MAAM;AACN,YAAM,UAAS,KAAK,cAAc,KAAKC,cAAI,CAAC,UAAa,SAAS,OAAO,QAAQ,KAAK;AACtF,WAAK,cAAc,SAAS,QAAQ;AACpC,aAAO;AAAA;AAEX,UAAM,sBAAsB;AAC5B,UAAM,SAAS,KAAK,cAAc,KAAKA,cAAI,CAAC,UAAa,oBAAoB,SAAS,KAAK;AAC3F,SAAK,cAAc,SAAS,QAAQ;AACpC,WAAO;AAAA;AAAA,EAGH,UAAgB;AACpB,SAAK,cACA,KAAKC,kCACL,UAAU,CAAE,MAAM,CAAC,UAAa,QAAQ,IAAI,CAAE,QAAQ,KAAK,mBAAmB,WAAW;AAAA;AAAA,EAG1F,cAA8D;AAClE,WAAOC,UACHC,iBAAO,CAAC,MAAW,MAAM,QAAQ,MAAM,SACvCF;AAAA;AAAA;MAMC,oBAAoB;AAAA,EAC7B,QAAQ;AAAA;MAeC,eAAe,CAAO,OAAe,aAA6C,OAAO;MAQzF,iBAAiB,CAAgB,aAAoD;MAOrF,mBAAmB,CAAI,eAAwC;AACxE,SAAO,IAAI,kBAAkB;AAAA;gCAGS,YAAe;AAAA,EACrD,YAAY,YAAe;AAAE,UAAM;AAAA;AAAA;;;;;;;;;"}